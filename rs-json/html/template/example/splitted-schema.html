<rs-container>
    <rs-spacer />
    <div class="col s12">
        <rs-breadcrumb>
            <rs-breadcrumb-item to="/rs-json" v-bind:text="$t('breadcrumb.home.text')" />
            <rs-breadcrumb-item to="/rs-json/example" v-bind:text="$t('breadcrumb.example.text')" />
            <rs-breadcrumb-item to="/rs-json/example/splitted-schema" v-bind:text="$t('breadcrumb.example.splittedSchema.text')" />
        </rs-breadcrumb>
    </div>
    <div class="col s12">
        <rs-paragraph>
            If you wonder how can you scale your schema, and avoid to put everything in one file, this section will fit your needs.
        </rs-paragraph>
        <rs-paragraph>
            RS/JSON was thought to be scalable at the begining. Using multiple schema, using a siple "dependency" key, you will be able to create an arborescence of smaller schema.
        </rs-paragraph>
        <rs-paragraph>
            Let us take the example of the book store. Imagine you are modelizing the <b>book part</b>, composed of books and their author. Imagine you also are modelizing orders between books.
        </rs-paragraph>
        <rs-paragraph>
            The example below shows how to take advantage of the <code>requires</code> key to build a splitted structured schema.
        </rs-paragraph>
    </div>
    <div class="col s12 m12 l6">
        <rs-card>
            <div slot="title">book-store-book.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
  "name": "book",
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type:" "string"
        },
        "author": {
          "type": "relation",
          "using": "author_id",
          "minimum": 1,
          "maximum": 1
        }
      }
    },
    "author": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        }
      }
    }
  }
}</rs-code>
            </div>
        </rs-card>
    </div>
    <div class="col s12 m12 l6">
        <rs-card>
            <div slot="title">book-store-order.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
  "requires": ["book"],
  "version": "0.1.0",
  "license": "MIT",
  "schema": {
    "order": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer"
        },
        "customer": {
          "type": "string"
        }
      }
    },
    "bookOrder": {
      "properties": {
        "book": {
          "type": "relation",
          "for": "book",
          "using": "book_id",
          "minimum": 0,
          "maximum": null
        },
        "order": {
          "type": "relation",
          "for": "order",
          "using": "order_id",
          "minimum": 0,
          "maximum": null
        }
      }
    }
  }            
}</rs-code>
            </div>
        </rs-card>
    </div>
    <div class="col s12">
        <rs-paragraph>
            As you can see, the first schema is a regular schema like seen in previous example, and contains an additional <code>name</code> key to identify it.
        </rs-paragraph>
        <rs-paragraph>
            The second schema uses a <code>requires</code> key to tell the RS/JSON interpreter that this schema cannot be ran before the first schema. This is how you can define a tree-oriented schema, and keep it the simplest possible.
        </rs-paragraph>
    </div>
</rs-container>