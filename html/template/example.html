<rs-container>
        <rs-spacer />
        <div class="col s12">
            <rs-breadcrumb>
                <rs-breadcrumb-item to="/rs-json" v-bind:text="$t('breadcrumb.home.text')" />
                <rs-breadcrumb-item to="/rs-json/example" v-bind:text="$t('breadcrumb.example.text')" />
            </rs-breadcrumb>
        </div>
        <rs-spacer />
        <div class="col s12">
            <p class="flow-text">
                {{ $t('example.inOrderToUnderstand') }}
            </p>
        </div>
        <rs-spacer />
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <div class="center-align">
                <img class="materialboxed" width="100%" src="/rs-json/img/example-book-store.svg" />
            </div>
        </div>
        <rs-spacer />
        <div class="col s12">
            <p class="flow-text">
                {{ $t('example.problemsWithDiagrams') }}
            </p>
            <p class="flow-text">
                {{ $t('example.howRsJsonTackleDiagramsProblems') }}
            </p>
            <ol>
                <li v-html="$t('example.statement.bookIsbnName')"></li>
                <li v-html="$t('example.statement.bookAuthor')"></li>
                <li v-html="$t('example.statement.authorNameAge')"></li>
                <li v-html="$t('example.statement.authorBooks')"></li>
                <li v-html="$t('example.statement.orderDateBorrowingReturning')"></li>
                <li v-html="$t('example.statement.bookOrder')"></li>
            </ol>
        </div>
        <div class="col s12">
            <p class="flow-text">
                {{ $t('example.fairEnough') }}
            </p>
        </div>
        <rs-spacer />
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">
                book-store.rs.json
              </div>
                    <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "isbn": {
          "type": "string"
        }
      }
    }
  }                
}</rs-code>

                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <p class="flow-text">
                {{ $t('example.goodStart') }}
            </p>
        </div>
        <div class="col s12">
            <blockquote class="flow-text">
                <i v-html="$t('example.goodStartQuote')"></i>
            </blockquote>
        </div>
        <div class="col s12">
            <rs-paragraph v-html="$t('example.thisMeansIsbnParticularForm')"></rs-paragraph>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "isbn": {
          "type": "string",
          "guards": ["isbn-13"]
        }
      }
    }
  }                
}</rs-code>
</rs-card>
                </div>
        </div>
        <div class="col s12">
            <p class="flow-text">
                {{ $t('example.thisGuardIsCodedInYourBackend') }}
            </p>
            <rs-paragraph>{{ $t('example.guardArePerformingServerSide') }}</rs-paragraph>
            <rs-paragraph>{{ $t('example.weCouldAlsoHaveTheDatabase') }}</rs-paragraph>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "isbn": {
          "type": "isbn-13"
        }
      }
    }
  }                
}</rs-code>
                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <p class="flow-text">
              This includes: <code>"maximum": 17</code>, <code>"guards": ["isbn-13"]</code>, <code>"type": "string"</code>. Sometimes you better make a custom type if you feel the property is getting too much parameters or you want to reuse a set of parameters.
            </p>
            <p class="flow-text">
                Good job. One more thing to take into account:
            </p>
            <blockquote class="flow-text">
                <i>A book <b>must</b> have a name and an ISBN</i>
            </blockquote>
            <p class="flow-text">
                Using RS/JSON, this is something very explicit:
            </p>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string",
          "required": true
        },
        "isbn": {
          "type": "isbn-13",
          "required": true
        }
      }
    }
  }                
}</rs-code>
                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <rs-paragraph>We often use an integer as an identifier in our app for each of our records. Let us specify the <code>id</code> property is our primary key:</rs-paragraph>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string",
          "required": true
        },
        "isbn": {
          "type": "isbn-13",
          "required": true
        }
      }
    }
  }                
}</rs-code>
                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <p class="flow-text">
                Since this is an integer, we can let the database incrementing the property <code>id</code> for us. Let us make the database aware of this:
            </p>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true
        },
        "isbn": {
          "type": "isbn-13",
          "required": true
        }
      }
    }
  }                
}</rs-code>
                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <p class="flow-text">
                This begins to look great. Let us handle the author.
            </p>
            <blockquote class="flow-text">
                A book <b>must</b> have <b>only one</b> author
            </blockquote>
            <p class="flow-text">
                Here is how you would specify such a relation:
            </p>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
            <rs-card>
              <div slot="title">book-store.rs.json</div>
                <div slot="content">
                    <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true
        },
        "isbn": {
          "type": "isbn-13",
          "required": true
        },
        "author": {
          "type": "relation",
          "minimum": 1,
          "maximum": 1
        }
      }
    }
  }                
}</rs-code>
                </div>
              </rs-card>
        </div>
        <div class="col s12">
            <p class="flow-text">
                Here is what happens:
            </p>
            <ol>
                <li>The property name is only used by your ORM.</li>
                <li>The reference for the foreign key is automatically figured out using a standard notation: name of the relation + "_id", so it will correctly understand you are talking about <code>author_id</code></li>
                <li>The foreign column is by default <code>id</code>, and the foreign table is by default the name of the relation, so it correctly understands that you are referencing <code>author(id)</code></li>
            </ol>
            <p class="flow-text">
                In SQL, you can tell a column to not be null, but you cannot enforce a string column to be not empty. If you would like to achieve this, you can use a <router-link to="/rs-json/documentation/guards/native-guards">native guard</router-link> called <code>filled</code>. Let us make our name and isbn mandatory to finish with our book table:
            </p>
        </div>
        <div class="col s12 m10 l8 offset-m1 offset-l2">
          <rs-card>
            <div slot="title">book-store.rs.json</div>
              <div slot="content">
                  <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true,
          "guards": ["filled"]
        },
        "isbn": {
          "type": "isbn-13",
          "required": true,
          "guards": ["filled"]
        },
        "author": {
          "type": "relation",
          "minimum": 1,
          "maximum": 1
        }
      }
    }
  }                
}</rs-code>
              </div>
            </rs-card>
      </div>
      <div class="col s12">
        <p class="flow-text">
          Also, if you remember, the <code>"type": "isbn-13"</code> also contains a guard, <code>"guards": ["isbn-13"]</code> inside of it. It will be appended to the guards you choose, so in reality the isbn will have 2 guards: <code>"guards": ["isbn-13", "filled"]</code>.
        </p>
        <p class="flow-text">
          One last improvements would be to make the isbn unique. With RS/JSON here is how you would do that:
        </p>
      </div>
      <div class="col s12 m10 l8 offset-m1 offset-l2">
        <rs-card>
          <div slot="title">book-store.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
"version": "0.1.0",
"license": "MIT",
"charset": "utf8",
"schema": {
  "book": {
    "identifier": ["id"],
    "uniques": {
      "unique_book_isbn": ["isbn"]
    },
    "properties": {
      "id": {
        "type": "integer",
        "incremented": true
      },
      "name": {
        "type": "string",
        "guards": ["filled"]
      },
      "isbn": {
        "type": "isbn-13",
        "required": true,
        "guards": ["filled"]
      },
      "author": {
        "type": "relation",
        "minimum": 1,
        "maximum": 1
      }
    }
  }
}                
}</rs-code>
            </div>
          </rs-card>
      </div>
      <div class="col s12">
        <p class="flow-text">
          The <code>uniques</code> property contains a key-value pair, with each key being the name of the unique constraint, and the value being the list of columns to complete the constraint.
        </p>
      </div>
      <div class="col s12">
        <p class="flow-text">
          In order to make this schema, we should add the missing author model.
        </p>
      </div>
      <div class="col s12 m10 l8 offset-m1 offset-l2">
        <rs-card>
          <div slot="title">book-store.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
"version": "0.1.0",
"license": "MIT",
"charset": "utf8",
"schema": {
  "book": {
    "identifier": ["id"],
    "uniques": {
      "unique_book_isbn": ["isbn"]
    },
    "properties": {
      "id": {
        "type": "integer",
        "incremented": true
      },
      "name": {
        "type": "string",
        "guards": ["filled"]
      },
      "isbn": {
        "type": "isbn-13",
        "required": true,
        "guards": ["filled"]
      },
      "author": {
        "type": "relation",
        "minimum": 1,
        "maximum": 1
      }
    }
  },
  "author": {
    "identifier": ["id"],
    "uniques": {
      "unique_author": ["first_name", "last_name"]
    },
    "properties": {
      "id": {
        "type": "integer",
        "incremented": true
      },
      "first_name": {
        "type": "string",
        "required": true,
        "guards": ["filled", "name"]
      },
      "last_name": {
        "type": "string",
        "required": true,
        "guards": ["filled", "name"]
      },
      "birth_date": {
        "type": "date",
        "guards": ["adult"]
      }
    }
  }
}                
}</rs-code>
            </div>
          </rs-card>
      </div>
      <div class="col s12">
        <p class="flow-text">
          The schema will run correctly, but we could also add the inverse of the book->author relation.
        </p>
      </div>
      <div class="col s12 m10 l8 offset-m1 offset-l2">
        <rs-card>
          <div slot="title">book-store.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "uniques": {
        "unique_book_isbn": ["isbn"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true,
          "guards": ["filled"]
        },
        "isbn": {
          "type": "isbn-13",
          "required": true,
          "guards": ["filled"]
        },
        "author": {
          "type": "relation",
          "minimum": 1,
          "maximum": 1
        }
      }
    },
    "author": {
      "identifier": ["id"],
      "uniques": {
        "unique_author": ["first_name", "last_name"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "first_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "last_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "birth_date": {
          "type": "date",
          "guards": ["adult"]
        },
        "books": {
          "type": "relation",
          "for": "book",
          "minimum": 0
        }
      }
    }
  }                
}</rs-code>
            </div>
          </rs-card>
      </div>
      <div class="col s12">
        <p class="flow-text">
          As you can see, there is several things. Let us break this down again.
        </p>
        <p class="flow-text">
          The <code>books</code> property is understood by your database because it has an additional <code>for</code> key which reference the target table. No need a key, because by default the <code>id</code> field is found in the target table.
        </p>
        <p class="flow-text">
          Not specifying a <code>maximum</code> means it does not have limited number of related models. This relation means an author can have between 0 and an infinity of books.
        </p>
        <rs-paragraph>To finish, let us add the order model.</rs-paragraph>
      </div>
      <div class="col s12 m10 l8 offset-m1 offset-l2">
        <rs-card>
            <div slot="content">
                <div slot="title">book-store.rs.json</div>
                <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "uniques": {
        "unique_book_isbn": ["isbn"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true,
          "guards": ["filled"]
        },
        "isbn": {
          "type": "isbn-13",
          "required": true,
          "guards": ["filled"]
        },
        "author": {
          "type": "relation",
          "minimum": 1,
          "maximum": 1
        }
      }
    },
    "author": {
      "identifier": ["id"],
      "uniques": {
        "unique_author": ["first_name", "last_name"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "first_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "last_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "birth_date": {
          "type": "date",
          "guards": ["adult"]
        },
        "books": {
          "type": "relation",
          "for": "book",
          "minimum": 0
        }
      }
    },
    "order": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "borrowed_date": {
          "type": "datetime",
          "required": true
        },
        "returned_date": {
          "type": "datetime",
          "required": true,
          "guards": ["not-before:borrowed_date"]
        },
        "lector_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        }
      }
    }
  }
}</rs-code>
            </div>
          </rs-card>
      </div>
      <div class="col s12">
        <p class="flow-text">
          To conclude this example, let us tackle the last statement together.
        </p>
        <blockquote class="flow-text">
            An Book can be ordered <b>many</b> times, and an Order can have <b>many</b> books
        </blockquote>
        <p class="flow-text">
          For the one having worked with relational schema for database, this might make you think of "many to many" relationship, and this is exactly the case for books and orders. Here is how to conceptualize it using RS/JSON.
        </p>
      </div>
      <div class="col s12 m10 l8 offset-m1 offset-l2">
        <rs-card>
          <div slot="title">book-store.rs.json</div>
            <div slot="content">
                <rs-code lang="json">{
  "version": "0.1.0",
  "license": "MIT",
  "charset": "utf8",
  "schema": {
    "book": {
      "identifier": ["id"],
      "uniques": {
        "unique_book_isbn": ["isbn"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "name": {
          "type": "string",
          "required": true,
          "guards": ["filled"]
        },
        "isbn": {
          "type": "isbn-13",
          "required": true,
          "guards": ["filled"]
        },
        "author": {
          "type": "relation",
          "minimum": 1,
          "maximum": 1
        },
        "orders": {
          "type": "relation",
          "for": "order",
          "through": "book_order"
        }
      }
    },
    "author": {
      "identifier": ["id"],
      "uniques": {
        "unique_author": ["first_name", "last_name"]
      },
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "first_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "last_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "birth_date": {
          "type": "date",
          "guards": ["adult"]
        },
        "books": {
          "type": "relation",
          "for": "book",
          "minimum": 0
        }
      }
    },
    "order": {
      "identifier": ["id"],
      "properties": {
        "id": {
          "type": "integer",
          "incremented": true
        },
        "borrowed_date": {
          "type": "datetime",
          "required": true
        },
        "returned_date": {
          "type": "datetime",
          "required": true,
          "guards": ["not-before:borrowed_date"]
        },
        "lector_name": {
          "type": "string",
          "required": true,
          "guards": ["filled", "name"]
        },
        "books": {
          "type": "relation",
          "for": "book",
          "through": "book_order"
        }
      }
    }
  }
}</rs-code>
            </div>
          </rs-card>
      </div>
      <div class="col s12">
        <rs-paragraph>We added <code>orders</code> relationship on Book model and <code>books</code> relation on Order model. The <code>through</code> key specify through which join table the ORM should grab, insert or update the data.</rs-paragraph>
        <rs-paragraph>This last change on our RS/JSON schema will end this example. We hope it helped you catch the concept.</rs-paragraph>
        <rs-paragraph>To go deeper, check the <router-link to="/rs-json/documentation">documentation</router-link>.</rs-paragraph>
      </div>
    </div>
    <rs-edit-proposal-fab href="/html/template/example.html" />
  </rs-container>